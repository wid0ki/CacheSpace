<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>alg</class>
 <widget class="QDialog" name="alg">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>699</width>
    <height>360</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Algorithm Info</string>
  </property>
  <widget class="QTextBrowser" name="textBrowser">
   <property name="geometry">
    <rect>
     <x>0</x>
     <y>0</y>
     <width>701</width>
     <height>361</height>
    </rect>
   </property>
   <property name="html">
    <string>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;
&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
p, li { white-space: pre-wrap; }
&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'Lucida Grande'; font-size:13pt; font-weight:400; font-style:normal;&quot;&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;1. Про кэш-память&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Основная идея кэш-памяти проста: в ней находятся слова, которые чаще всего используются. Если процессору нужно какое-то слово, то сначала он обращается к кэш-памяти. Только в том случае, если слова там нет, он обращается к основной памяти.&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Основу всех систем кэш-памяти составляет &lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt; font-weight:600;&quot;&gt;принцип локальности&lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;. &lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt; font-weight:600;&quot;&gt;Пространственная локализация&lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt; заключается в том, что при последовательных отсылках к памяти в течение некоторого промежутка времени используется только небольшой ее участок, поэтому, когда определенное слово вызывается из памяти, оно вместе с соседними словами переносится в кэш-память. Основная и кэш-память делятся на блоки фиксированного размера с учетом принципа локальности. Блоки внутри кэш-памяти называются строками кэш-памяти. Если обращение к кэш-памяти не результативно, из основной памяти в кэш-памяти загружается вся строка, а не только необходимое слово. &lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt; font-weight:600;&quot;&gt;Временная локализация&lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt; имеет место, когда недавно запрашиваемые ячейки запрашиваются снова (например, команды внутри цикла) [1]. &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Существует две политики реагирования на изменения данных в кэш памяти: кэш с немедленной записью и кэш с отложенной записью. В кэше с немедленной записью каждое изменение вызывает синхронное обновление данных в основной памяти. В кэше с отложенной записью обновление происходит в случае вытеснения элемента данных, периодически или по запросу клиента. Для отслеживания модифицированных элементов данных записи кэша хранят признак модификации («validity bit»). Промах в кэше с отложенной записью может потребовать два обращения к основной памяти: первое для записи заменяемых данных из кэша, второе для чтения необходимого элемента данных. &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Каждый элемент кэш-памяти состоит из трех частей: &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;1)                     бита достоверности, указывающего есть ли достоверные данные в элементе или нет;&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;2)                     поля тег, состоящего из уникального 16-битного значения, указывающего соответствующую строку памяти, из которой поступили данные;&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;3)                     поля данные, содержащего копию данных памяти [2].&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Когда центральный процессор выдает адрес памяти, аппаратное обеспечение выделяет из этого адреса поле данные и использует его для поиска в кэш-памяти. Если найденный элемент действителен, то происходит сравнение поля тег основной памяти и поля тег кэш-памяти. Если поля равны, значит, в кэш-памяти есть слово, которое запрашивается. Такая ситуация называется удачным обращением в кэш-память, слово берется из кэш-памяти и, тогда, не нужно обращаться к основной памяти. Если элемент кэш-памяти не действителен или поля тег не совпадают, то нужного слова нет в памяти такая ситуация называется промахом кэш-памяти. В этом случае строка вызывается из основной памяти и сохраняется в кэш-памяти, заменяя элемент, который там был.&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;2.  Least Recently Used&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;LRU (Least Recently Used) – алгоритм удаления наиболее давно использовавшихся элементов. Этот алгоритм требует отслеживания того, что и когда использовалось, что может оказаться довольно накладно, поскольку каждый такт требуется полный проход по кэш-памяти для увеличения «бита возраста» всех элементов. Общая реализация этого метода требует сохранения «бита возраста» для строк кэша и за счет этого происходит отслеживание наименее использованных строк (то есть за счет сравнения таких битов). В подобной реализации, при каждом обращении к строке кэша меняется «возраст» всех остальных строк [1, 13]. Хотя можно было бы и использовать упорядоченный по возрастанию времени нахождения в кэше список, и при каждом попадание в кэш переносить элемент в начало списка, а при промахе – удалять последний элемент с конца. Такая реализация позволила бы избавиться от дополнительного прохода по всей кэш памяти для изменения «бита возраста», однако, понадобилось бы постоянное выполнение операции вставки и удаления из списка. [14] &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Строго говоря, LRU – это семейство алгоритмов кэширования, в которое входят псевдо-LRU, сегментированный LRU, 2Q, LRU-K и другие. &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;3.        Most Recently Used&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;MRU (Most Recently Used) – алгоритм вытеснения последнего использованного элемента [1]. В выводах, предоставленных на 11-й Very Large Data Base, Чжоу и Девитт отметили, что «MRU является лучшим алгоритмом вытеснения данных при цикличном сканировании файла» [15]. Впоследствии, исследования, представленные Ш. Даром, М. Франклином и Б. Джонсоном на 22-й VLDB, показали, что для случайной модели доступа и повторного сканирования крупных наборов данных (циклической модели доступа) MRU характеризуется большим попаданием в кэш-память, чем LRU, в связи с его тенденцией к сохранению старых данных. MRU алгоритмы являются наиболее полезными в ситуациях, когда чем дольше данные находятся в кэше, тем больше вероятность того, что понадобится получить к ним доступ [16]. Этот алгоритм так же требует наличие «бита возраста», если для его реализации мы не будем пользоваться упорядоченной структурой, описанной в 1.2 с той лишь разницей, что при промахе элемент будет удаляться из начала списка.&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;4.        Псевдо-LRU&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Кэш-память с n возможными элементами для каждого адреса называется n-входной ассоциативной кэш-памятью. Фактически это означает, что в каждой ячейке кэш-памяти хранятся записи о двух ячейках в оперативной памяти, таким образом, кэш-память состоит из множества сочетаний по n-элементов из промахов кэш-памяти. Это увеличивает вероятность нахождения элемента в кэше, однако, чтобы его найти, требуется проверить n-элементов кэша. Но двухвходная и четырехвходная ассоциативная кэш-память эффективнее кэша прямого отображения. Для кэша с большой ассоциативностью реализация становится бессмысленна [18, 21].&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Политика вытеснения PLRU – вариант LRU, где «биты возраста» упорядочены не линейно, а организованы в виде бинарного дерева. Это дает преимущество в том, что необходимо меньше «битов возраста», а, значит, нужна менее сложная логика обновления «битов возраста». Средняя производительность PLRU сравнима с производительностью LRU, а в худшем случае – хуже WCET (Worst-Case execution time – наихудшее время выполнения) LRU[17].&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;5.        Random Replacement&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;RR (Random Replacement) – алгоритм случайной замены. Случайным образом выбирает запись в кэш-памяти и заменяет ее, в случае отсутствия свободного буфера. Такая политика вытеснения использовалась в ARM-процессорах [19]. В общем случае, это семейство алгоритмов, использующих случайное вытеснение. Некоторые реализации RR эффективнее классического LRU.&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Алгоритм маркировки ставит в соответствие каждому элементу в кэш-памяти определенный идентификатор («marker bit»), первоначально равный нулю. Когда производится доступ к элементу из кэш-памяти, для страницы устанавливается маркер. При промахе кэша вытесняется выбранный случайным образом элемент с неустановленным маркером. Алгоритм маркировки эффективнее классического RR, однако, его производительность возрастает не экспоненциально [20].&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;6.        LRU-K&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;LRU/K представлен П. О’Нилом, Б. О’Нил и Г. Вейкумом в 1993 году. Основная идея в LRU/K в том, что отслеживается время последнего вызова страницы из памяти и используется статистическая информация о рангах страниц, определяющих их будущее поведение. Исходя из этого, вытесняются те страницы, вызов которых не будет произведен в ближайшее время. Преимущества LRU/K в том, что он обнаруживает локальности ссылок в запросе на вытеснение элемента из кэша, через несколько запросов в одной и той же стоке или через несколько вызовов слов из кэша, происходящих одновременно. LRU/K призван избавиться от недостатков алгоритма LRU, который принимает решение о вытеснение данных из кэша на основе малой информации, ограничивающейся лишь последним временем вызова. LRU/K использует идею принятия решений на основе последних K вызовов для каждого элемента кэша. При K=1 LRU/K  является классическим LRU, а при больших значениях K стремится к LFU. В настоящее время П. О’Нил, Б. О’Нил и Г. Вейкум доказали, что LRU-2 эффективнее LRU [7].&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;7.        Сегментированный LRU&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Сегментированный LRU (Segmented LRU или SLRU) описан Рамакришной Каредлой, Спенсером Лавом и Бредли Верри в 1994 году. &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;SLRU-кэш делится на две части: пробный сегмент и конечный сегмент. Строки в каждом сегменте упорядочены по убыванию частоты использования. Данные при промахах добавляются в пробный сегмент, а при попадания переносятся в область часто используемых элементов конечного сегмента. К строкам конечного сегмента обращения, таким образом, происходят, по крайней мере, дважды. Конечный сегмент ограничен и меняется в зависимости от схемы работы ввода-вывода. Такой перенос строки из пробного сегмента в конечный сегмент может вызвать перенос последней использованной (LRU) строки в конечном сегменте в MRU-область пробного сегмента, давая этой линии второй шанс быть использованной перед вытеснением. Всякий раз, когда данные должны быть вытеснены из кэша, строки запрашиваются из LRU-конца пробного сегмента [21].&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;8. Least Frequently Used&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Least Frequently Used (LFU) – алгоритм, основанный на частотности употребления элементов и имеющий большую эффективность, чем LRU. Он подсчитывает, как часто вызывается тот или иной элемент в процессе работы и в случае промаха, вытесняет самый редко используемый элемент. Поскольку, хранить характеристики частоты использования всех элементов слишком затратно, то частоту можно использования можно считать только для тех элементов, которые находятся в кэш-памяти. Можно использовать бит частотности – счетчик вызовов элемента [10].&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;9.        Adaptive Replacement Cache&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#ffffff;&quot;&gt;&lt;span style=&quot; font-size:12pt;&quot;&gt;Adaptive Replacement Cache (ARC) был представлен на USENIX Conference on File and Storage Technologies (FAST) научно-исследовательским центром Almaden компании IBM в 2003 году. &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;В настоящее время ARC используется в контроллерах хранения данных DS6000/DS8000 компании IBM, является альтернативной политикой вытеснения в ОС Solaris, кроме того, ARC долгое время применялась Oracle в СУБД PostgreSQL. &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Идея ARC состоит в создании самонастраивающейся политике вытеснения, которая балансирует между LRU и LFU. Память делится на два участка одинакового размера L1 и L2. В L1 хранятся элементы, которые были вызваны один раз за последнее время, упорядоченные по новизне. В L2 хранятся элементы, которые были вызваны, по крайней мере, дважды. В L2 элементы упорядочены по частоте использования. Если элемент содержится в L1, то оттуда вытесняют самый редко используемый элемент, иначе его вытесняют из L2, тогда между L1 и L2 содержатся самые часто используемые элементы. Обозначают верхние и нижние пределы L1 (T1 и B1) и L2 (T2 и B2). Далее устанавливается фиксированный перемещающийся кэш размером от Т1 до р. Если промежуток от Т1 до р содержит больше, чем р страниц, то вытесняется самый редко используемый элемент из Т1, иначе из Т2.&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Согласно проведенным исследованиям, ARC превосходит LRU при любых рабочих нагрузках на систему [11].&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;10. Multi Queue Caching Algorithm&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Multi Queue Caching Algorithm (MQ) – это политика вытеснения, поддерживающая очереди с элементами разной частотности употребления в различные периоды времени.&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;MQ использует многоуровневые очереди из элементов, упорядоченных по частотности их употребления Q&lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt; vertical-align:sub;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;, … , Q&lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt; vertical-align:sub;&quot;&gt;m-1&lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;, для системы с m различными параметрами. Элементы из очереди Q&lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt; vertical-align:sub;&quot;&gt;i &lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;находятся в кэше меньше, чем из очереди Q&lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt; vertical-align:sub;&quot;&gt;j&lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt; при условии, что i&amp;lt;j. В качестве параметров могут выбираться стоимость элементов, размер, который они занимают в кэше, актуальность данных и так далее [6].&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;11. 2Q&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Алгоритм 2Q (Two Queue) был создан для того, чтобы снизить время доступа к ячейкам памяти с сохранением без дополнительной настройки производительности, достигаемой LRU/2. &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;LRU работал хорошо, поскольку стремился удалить неиспользуемые долгое время элементы из буфера, освобождая место для других элементов в случае промаха кэша. Однако случалось так, что приходилось вытеснять часто используемый элемент другим, с меньшей частотой употребления. В итоге, менее используемый элемент находился в кэше продолжительное время. LRU/2 улучшил LRU благодаря улучшенному правилу вытеснения, которое быстро удаляло редко используемые элементы из буфера. Реализация такой политики вытеснения требует работы с приоритетной очередью.&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;В отличие от LRU 2Q был вместо того, чтобы очищать редко используемые элементы из кэша, принимает туда только часто используемые. Это работает следующим образом, при первой ссылке на элемент 2Q перемещает его в специальный буфер Al – очередь, организованная по принципу FIFO. Если элемент вызывается m раз из очереди Al, то, возможно, он является часто используемым, тогда он перемещается в очередь Am из элементов, упорядоченных по «битам возраста». Если элемент за определенное время не вызвали m раз, то, возможно, он является редко используемым, и он удаляется из буфера Al [4].&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;12. Алгоритм Белади &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Алгоритм Белади (минимум Белади, алгоритм предвидения) – это теоретический алгоритм, представленный в 1966 году венгерским ученым Ласло Белади. Это наиболее эффективная политика вытеснения, поскольку из кэш-памяти вытесняется та информация, которая дольше всего не будет использована. Поскольку в реальной жизни не всегда можно предугадать, какие данные в последствие понадобятся системе – реализации данного алгоритма для общего случая не существует [5].Основная идея кэш-памяти проста: в ней находятся слова, которые чаще всего используются. Если процессору нужно какое-то слово, то сначала он обращается к кэш-памяти. Только в том случае, если слова там нет, он обращается к основной памяти.&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Основу всех систем кэш-памяти составляет &lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt; font-weight:600;&quot;&gt;принцип локальности&lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;. &lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt; font-weight:600;&quot;&gt;Пространственная локализация&lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt; заключается в том, что при последовательных отсылках к памяти в течение некоторого промежутка времени используется только небольшой ее участок, поэтому, когда определенное слово вызывается из памяти, оно вместе с соседними словами переносится в кэш-память. Основная и кэш-память делятся на блоки фиксированного размера с учетом принципа локальности. Блоки внутри кэш-памяти называются строками кэш-памяти. Если обращение к кэш-памяти не результативно, из основной памяти в кэш-памяти загружается вся строка, а не только необходимое слово. &lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt; font-weight:600;&quot;&gt;Временная локализация&lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt; имеет место, когда недавно запрашиваемые ячейки запрашиваются снова (например, команды внутри цикла) [1]. &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Существует две политики реагирования на изменения данных в кэш памяти: кэш с немедленной записью и кэш с отложенной записью. В кэше с немедленной записью каждое изменение вызывает синхронное обновление данных в основной памяти. В кэше с отложенной записью обновление происходит в случае вытеснения элемента данных, периодически или по запросу клиента. Для отслеживания модифицированных элементов данных записи кэша хранят признак модификации («validity bit»). Промах в кэше с отложенной записью может потребовать два обращения к основной памяти: первое для записи заменяемых данных из кэша, второе для чтения необходимого элемента данных. &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Каждый элемент кэш-памяти состоит из трех частей: &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;1)                     бита достоверности, указывающего есть ли достоверные данные в элементе или нет;&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;2)                     поля тег, состоящего из уникального 16-битного значения, указывающего соответствующую строку памяти, из которой поступили данные;&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;3)                     поля данные, содержащего копию данных памяти [2].&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Когда центральный процессор выдает адрес памяти, аппаратное обеспечение выделяет из этого адреса поле данные и использует его для поиска в кэш-памяти. Если найденный элемент действителен, то происходит сравнение поля тег основной памяти и поля тег кэш-памяти. Если поля равны, значит, в кэш-памяти есть слово, которое запрашивается. Такая ситуация называется удачным обращением в кэш-память, слово берется из кэш-памяти и, тогда, не нужно обращаться к основной памяти. Если элемент кэш-памяти не действителен или поля тег не совпадают, то нужного слова нет в памяти такая ситуация называется промахом кэш-памяти. В этом случае строка вызывается из основной памяти и сохраняется в кэш-памяти, заменяя элемент, который там был.&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;1.2.  Least Recently Used&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;LRU (Least Recently Used) – алгоритм удаления наиболее давно использовавшихся элементов. Этот алгоритм требует отслеживания того, что и когда использовалось, что может оказаться довольно накладно, поскольку каждый такт требуется полный проход по кэш-памяти для увеличения «бита возраста» всех элементов. Общая реализация этого метода требует сохранения «бита возраста» для строк кэша и за счет этого происходит отслеживание наименее использованных строк (то есть за счет сравнения таких битов). В подобной реализации, при каждом обращении к строке кэша меняется «возраст» всех остальных строк [1, 13]. Хотя можно было бы и использовать упорядоченный по возрастанию времени нахождения в кэше список, и при каждом попадание в кэш переносить элемент в начало списка, а при промахе – удалять последний элемент с конца. Такая реализация позволила бы избавиться от дополнительного прохода по всей кэш памяти для изменения «бита возраста», однако, понадобилось бы постоянное выполнение операции вставки и удаления из списка. [14] &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Строго говоря, LRU – это семейство алгоритмов кэширования, в которое входят псевдо-LRU, сегментированный LRU, 2Q, LRU-K и другие. &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;1.3.        Most Recently Used&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;MRU (Most Recently Used) – алгоритм вытеснения последнего использованного элемента [1]. В выводах, предоставленных на 11-й Very Large Data Base, Чжоу и Девитт отметили, что «MRU является лучшим алгоритмом вытеснения данных при цикличном сканировании файла» [15]. Впоследствии, исследования, представленные Ш. Даром, М. Франклином и Б. Джонсоном на 22-й VLDB, показали, что для случайной модели доступа и повторного сканирования крупных наборов данных (циклической модели доступа) MRU характеризуется большим попаданием в кэш-память, чем LRU, в связи с его тенденцией к сохранению старых данных. MRU алгоритмы являются наиболее полезными в ситуациях, когда чем дольше данные находятся в кэше, тем больше вероятность того, что понадобится получить к ним доступ [16]. Этот алгоритм так же требует наличие «бита возраста», если для его реализации мы не будем пользоваться упорядоченной структурой, описанной в 1.2 с той лишь разницей, что при промахе элемент будет удаляться из начала списка.&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;1.4.        Псевдо-LRU&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Кэш-память с n возможными элементами для каждого адреса называется n-входной ассоциативной кэш-памятью. Фактически это означает, что в каждой ячейке кэш-памяти хранятся записи о двух ячейках в оперативной памяти, таким образом, кэш-память состоит из множества сочетаний по n-элементов из промахов кэш-памяти. Это увеличивает вероятность нахождения элемента в кэше, однако, чтобы его найти, требуется проверить n-элементов кэша. Но двухвходная и четырехвходная ассоциативная кэш-память эффективнее кэша прямого отображения. Для кэша с большой ассоциативностью реализация становится бессмысленна [18, 21].&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Политика вытеснения PLRU – вариант LRU, где «биты возраста» упорядочены не линейно, а организованы в виде бинарного дерева. Это дает преимущество в том, что необходимо меньше «битов возраста», а, значит, нужна менее сложная логика обновления «битов возраста». Средняя производительность PLRU сравнима с производительностью LRU, а в худшем случае – хуже WCET (Worst-Case execution time – наихудшее время выполнения) LRU[17].&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;1.5.        Random Replacement&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;RR (Random Replacement) – алгоритм случайной замены. Случайным образом выбирает запись в кэш-памяти и заменяет ее, в случае отсутствия свободного буфера. Такая политика вытеснения использовалась в ARM-процессорах [19]. В общем случае, это семейство алгоритмов, использующих случайное вытеснение. Некоторые реализации RR эффективнее классического LRU.&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Алгоритм маркировки ставит в соответствие каждому элементу в кэш-памяти определенный идентификатор («marker bit»), первоначально равный нулю. Когда производится доступ к элементу из кэш-памяти, для страницы устанавливается маркер. При промахе кэша вытесняется выбранный случайным образом элемент с неустановленным маркером. Алгоритм маркировки эффективнее классического RR, однако, его производительность возрастает не экспоненциально [20].&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;1.6.        LRU-K&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;LRU/K представлен П. О’Нилом, Б. О’Нил и Г. Вейкумом в 1993 году. Основная идея в LRU/K в том, что отслеживается время последнего вызова страницы из памяти и используется статистическая информация о рангах страниц, определяющих их будущее поведение. Исходя из этого, вытесняются те страницы, вызов которых не будет произведен в ближайшее время. Преимущества LRU/K в том, что он обнаруживает локальности ссылок в запросе на вытеснение элемента из кэша, через несколько запросов в одной и той же стоке или через несколько вызовов слов из кэша, происходящих одновременно. LRU/K призван избавиться от недостатков алгоритма LRU, который принимает решение о вытеснение данных из кэша на основе малой информации, ограничивающейся лишь последним временем вызова. LRU/K использует идею принятия решений на основе последних K вызовов для каждого элемента кэша. При K=1 LRU/K  является классическим LRU, а при больших значениях K стремится к LFU. В настоящее время П. О’Нил, Б. О’Нил и Г. Вейкум доказали, что LRU-2 эффективнее LRU [7].&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;1.7.        Сегментированный LRU&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Сегментированный LRU (Segmented LRU или SLRU) описан Рамакришной Каредлой, Спенсером Лавом и Бредли Верри в 1994 году. &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;SLRU-кэш делится на две части: пробный сегмент и конечный сегмент. Строки в каждом сегменте упорядочены по убыванию частоты использования. Данные при промахах добавляются в пробный сегмент, а при попадания переносятся в область часто используемых элементов конечного сегмента. К строкам конечного сегмента обращения, таким образом, происходят, по крайней мере, дважды. Конечный сегмент ограничен и меняется в зависимости от схемы работы ввода-вывода. Такой перенос строки из пробного сегмента в конечный сегмент может вызвать перенос последней использованной (LRU) строки в конечном сегменте в MRU-область пробного сегмента, давая этой линии второй шанс быть использованной перед вытеснением. Всякий раз, когда данные должны быть вытеснены из кэша, строки запрашиваются из LRU-конца пробного сегмента [21].&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;1.8. Least Frequently Used&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Least Frequently Used (LFU) – алгоритм, основанный на частотности употребления элементов и имеющий большую эффективность, чем LRU. Он подсчитывает, как часто вызывается тот или иной элемент в процессе работы и в случае промаха, вытесняет самый редко используемый элемент. Поскольку, хранить характеристики частоты использования всех элементов слишком затратно, то частоту можно использования можно считать только для тех элементов, которые находятся в кэш-памяти. Можно использовать бит частотности – счетчик вызовов элемента [10].&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;1.9.        Adaptive Replacement Cache&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#ffffff;&quot;&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt;Adaptive Replacement Cache (ARC) был представлен на USENIX Conference on File and Storage Technologies (FAST) научно-исследовательским центром Almaden компании IBM в 2003 году. &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;В настоящее время ARC используется в контроллерах хранения данных DS6000/DS8000 компании IBM, является альтернативной политикой вытеснения в ОС Solaris, кроме того, ARC долгое время применялась Oracle в СУБД PostgreSQL. &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Идея ARC состоит в создании самонастраивающейся политике вытеснения, которая балансирует между LRU и LFU. Память делится на два участка одинакового размера L1 и L2. В L1 хранятся элементы, которые были вызваны один раз за последнее время, упорядоченные по новизне. В L2 хранятся элементы, которые были вызваны, по крайней мере, дважды. В L2 элементы упорядочены по частоте использования. Если элемент содержится в L1, то оттуда вытесняют самый редко используемый элемент, иначе его вытесняют из L2, тогда между L1 и L2 содержатся самые часто используемые элементы. Обозначают верхние и нижние пределы L1 (T1 и B1) и L2 (T2 и B2). Далее устанавливается фиксированный перемещающийся кэш размером от Т1 до р. Если промежуток от Т1 до р содержит больше, чем р страниц, то вытесняется самый редко используемый элемент из Т1, иначе из Т2.&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Согласно проведенным исследованиям, ARC превосходит LRU при любых рабочих нагрузках на систему [11].&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;1.10. Multi Queue Caching Algorithm&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Multi Queue Caching Algorithm (MQ) – это политика вытеснения, поддерживающая очереди с элементами разной частотности употребления в различные периоды времени.&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;MQ использует многоуровневые очереди из элементов, упорядоченных по частотности их употребления Q&lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt; vertical-align:sub;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;, … , Q&lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt; vertical-align:sub;&quot;&gt;m-1&lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;, для системы с m различными параметрами. Элементы из очереди Q&lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt; vertical-align:sub;&quot;&gt;i &lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;находятся в кэше меньше, чем из очереди Q&lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt; vertical-align:sub;&quot;&gt;j&lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt; при условии, что i&amp;lt;j. В качестве параметров могут выбираться стоимость элементов, размер, который они занимают в кэше, актуальность данных и так далее [6].&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;1.11. 2Q&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Алгоритм 2Q (Two Queue) был создан для того, чтобы снизить время доступа к ячейкам памяти с сохранением без дополнительной настройки производительности, достигаемой LRU/2. &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;LRU работал хорошо, поскольку стремился удалить неиспользуемые долгое время элементы из буфера, освобождая место для других элементов в случае промаха кэша. Однако случалось так, что приходилось вытеснять часто используемый элемент другим, с меньшей частотой употребления. В итоге, менее используемый элемент находился в кэше продолжительное время. LRU/2 улучшил LRU благодаря улучшенному правилу вытеснения, которое быстро удаляло редко используемые элементы из буфера. Реализация такой политики вытеснения требует работы с приоритетной очередью.&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;В отличие от LRU 2Q был вместо того, чтобы очищать редко используемые элементы из кэша, принимает туда только часто используемые. Это работает следующим образом, при первой ссылке на элемент 2Q перемещает его в специальный буфер Al – очередь, организованная по принципу FIFO. Если элемент вызывается m раз из очереди Al, то, возможно, он является часто используемым, тогда он перемещается в очередь Am из элементов, упорядоченных по «битам возраста». Если элемент за определенное время не вызвали m раз, то, возможно, он является редко используемым, и он удаляется из буфера Al [4].&lt;/span&gt;&lt;span style=&quot; font-size:14pt;&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;1.12. Алгоритм Белади Алгоритм Белади (минимум Белади, алгоритм предвидения) – это теоретический алгоритм, представленный в 1966 году венгерским ученым Ласло Белади. Это наиболее эффективная политика вытеснения, поскольку из кэш-памяти вытесняется та информация, которая дольше всего не будет использована. Поскольку в реальной жизни не всегда можно предугадать, какие данные в последствие понадобятся системе – реализации данного алгоритма для общего случая не существует [5].&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Более захватывающее чтение:&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;1.&lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:7pt;&quot;&gt;             &lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Таненбаум Э. Архитектура компьютера. – Питер, 2003. – 698 с.&lt;/span&gt; &lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;2.&lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:7pt;&quot;&gt;             &lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Liptay J.S. Structural aspects of the System/360 Model 85. The Cache // IBM Systems Journal. – 1968. – Vol. 7. – No. 1. – P. 15-21.&lt;/span&gt; &lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;3.&lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:7pt;&quot;&gt;             &lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Meddigo N., Modha D.S. ARC: A self-tuning, low overhead replacement cache // Proceedings of FAST ’03: 2nd USENIX Conference on File and Storage Technologies. - San Francisco, 2003. – P. 115-130.&lt;/span&gt; &lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;4.&lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:7pt;&quot;&gt;             &lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Johnson T., Shasha D. 2Q: A Low Overhead High Performance Buffer Management Replacement Algorithm // Proceedings of the 20&lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt; vertical-align:super;&quot;&gt;th&lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt; VLDB Conference. – Chile, 1994. – P. 439-450.&lt;/span&gt; &lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;5.&lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:7pt;&quot;&gt;             &lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Belady L.A. A study of replacement algorithms for a virtual-storage computer. // IBM Systems Journal. – 1966. – Vol. 5 – No. 2. – P. 78 – 101.&lt;/span&gt; &lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;6.&lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:7pt;&quot;&gt;             &lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Zhou Y., Philbin J.F., Li K. The Multi-Queue Replacement Algorithm for Second Level Buer Caches // Proceedings of the 2001 USENIX Technical Conference (USENIX'01). – 2001. – P. 1-11&lt;/span&gt; &lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;7.&lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:7pt;&quot;&gt;             &lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;O’Neil E.J., O’Neil P.E., Weikum G.An Optimality Proof of the LRU-K Page Replacement Algorithm // Journal of the ACM. – 1999. – Vol. 46. – No. 1. – P. 92–112.&lt;/span&gt; &lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;8.&lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:7pt;&quot;&gt;             &lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Jouppi N.P. Improving Direct-Mapped Cache Performance by the Addition of a Small Fully-Associative Cache and Prefetch Buffers. // WRL Technical Note TN-14 – 1990.&lt;/span&gt; &lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;9.         Krakostas G., Serpanos D.N. Practical LFU Implementation for Web Caching // [Электронный ресурс] – Режим доступа:  ftp://ftp.cs.princeton.edu/techreports/2000/622.pdf&lt;/span&gt; &lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;10.         Shah K., Mitra A., Matani D. An O(1) algorithm for implementing the LFU cache eviction scheme. // [Электронный ресурс] – Режим доступа: http://dhruvbird.com/lfu.pdf&lt;/span&gt; &lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;11.         Megiddo N., Modha D.S. Adaptive Replacement Cache // [Электронный ресурс] – Режим доступа: http://www-vlsi.stanford.edu/smart_memories/protected/meetings/spring2004/arc-fast.pdf&lt;/span&gt; &lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;9.&lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:7pt;&quot;&gt;             &lt;/span&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;Jiang S., Zhang X. LIRS: An Efﬁcient Low Inter-reference Recency Set Replacement Policy to Improve Buffer Cache Performance // [Электронный ресурс] – Режим доступа: http://www.ece.eng.wayne.edu/~sjiang/pubs/papers/jiang02_LIRS.pdf&lt;/span&gt; &lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;13.          Swami A., Schiefer K.B. Estimating  Page  Fetches for Index Scans with Finite LRU  Buffers // VLDB Journal. – 1995. – Vol. 4. – P. 675-701.&lt;/span&gt; &lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;14.          LRU, метод вытеснения из кэша // [Электронный ресурс] – Режим доступа: http://habrahabr.ru/post/136758/&lt;/span&gt; &lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;15.          Chou H.-T., DeWitt D.J. An Evaluation of Buffer Management Strategies for Relational Database Systems // Proceedings of VLDB 85. – 1985. – P. 127-141.&lt;/span&gt; &lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;16.          Dar S., Franklin M.J., Jonsson B.T., Srivastava D., Tan M. Semantic Data Caching and Replacement // Proceedings of the 22-nd VLDB Conference. – 1996. – P. 330-341.&lt;/span&gt; &lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;17.          Berg C. PLRU Cache Domino Effects // [Электронный ресурс] – Режим доступа: http://moss.csc.ncsu.edu/~mueller/wcet06/accepted/7_paper.pdf&lt;/span&gt; &lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;18. Heckmann R., Langenbach M., Thesing S., Wilhelm R. The inﬂuence of processor architecture on the design and the results of WCET tools // IEEE Proc. – 91(7), July 2003.&lt;/span&gt; &lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;19. Bhattacharjee A., Debnath B.K. A New Cache Replacement Algorithm // IEEE conference on Communications, Computers and Signal Processing, – 2005.&lt;/span&gt; &lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;20. Psounis, K., Prabhakar, B., and Engler, D. A randomized cache replacement scheme approximating LRU // Conference on Information Sciences and Systems, Princeton University. – 2000&lt;/span&gt; &lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Times New Roman'; font-size:14pt;&quot;&gt;21. Sawant R., Ramaprasad B.H., Govindwar S., Mothe N. Memory Hierarchies-Basic Design and Optimization Techniques // [Электронный ресурс] – Режим доступа: http://atherate.com/Documents/CacheOptimizations-SurveyPaper.pdf&lt;/span&gt; &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
   </property>
  </widget>
 </widget>
 <resources/>
 <connections/>
</ui>
